


### 1.3 反射机制

#### 原理：

Class对象的由来是将.class文件读入内存，并为之创建一个Class对象。

#### 反射优缺点

1、优点：

​     在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。

2、缺点：

（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；

（2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。

#### 反射的用途

1、反编译：.class-->.java

2、通过反射机制访问java对象的属性，方法，构造方法等

3、当我们在使用IDE,比如Ecplise时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。

4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。

5、例如，在使用Strut2框架的开发过程中，我们一般会在struts.xml里去配置Action，比如

~~~xml
<action name="login" class="org.ScZyhSoft.test.action.SimpleLoginAction" method="execute">   
    <result>/shop/shop-index.jsp</result>           
    <result name="error">login.jsp</result>       
</action>
~~~

比如我们请求login.action时，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，从action中查找出name为login的Action，并根据class属性创建SimpleLoginAction实例，并用Invoke方法来调用execute方法，这个过程离不开反射。配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。

比如，加载数据库驱动的，用到的也是反射。

```java
Class.forName("com.mysql.jdbc.Driver"); // 动态加载mysql驱动
```

#### 反射机制常用的类

~~~java
Java.lang.Class;

Java.lang.reflect.Constructor;

Java.lang.reflect.Field;

Java.lang.reflect.Method;

Java.lang.reflect.Modifier;
~~~

#### 反射的基本使用

**1、获得Class：主要有三种方法：**

（1）Object-->getClass

（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性

（3）通过class类的静态方法：forName(String className)（最常用）

~~~java
package fanshe;
 
public class Fanshe {
	public static void main(String[] args) {
		//第一种方式获取Class对象  
		Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。
		Class stuClass = stu1.getClass();//获取Class对象
		System.out.println(stuClass.getName());
		
		//第二种方式获取Class对象
		Class stuClass2 = Student.class;
		System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个
		
		//第三种方式获取Class对象
		try {
			Class stuClass3 = Class.forName("fanshe.Student");//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名
			System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		
	}
}
~~~

注意，在运行期间，一个类，只有一个Class对象产生，所以打印结果都是true；

三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。

**2、判断是否为某个类的示例：**

一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。

~~~java
public native boolean isInstance(Object obj);
~~~

**3、创建实例：通过反射来生成对象主要有两种方法：**

（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。

~~~java
Class<?> c = String.class;
Object str = c.newInstance();
~~~



（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。

~~~java
//获取String的Class对象
Class<?> str = String.class;
//通过Class对象获取指定的Constructor构造器对象
Constructor constructor=c.getConstructor(String.class);
//根据构造器创建实例：
Object obj = constructor.newInstance(“hello reflection”);
~~~




**4、通过反射获取构造方法并使用：**

（1）批量获取的方法：

~~~java
public Constructor[] getConstructors()：所有"公有的"构造方法
public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)
~~~



（2）单个获取的方法，并调用：

~~~java
public Constructor getConstructor(Class... parameterTypes):获取单个的"公有的"构造方法：
public Constructor getDeclaredConstructor(Class... parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有；
~~~



（3） 调用构造方法：

Constructor-->newInstance(Object... initargs)

newInstance是 Constructor类的方法（管理构造函数的类）

api的解释为：newInstance(Object... initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。

它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象，并为之调用。

例子：

Student类：共六个构造方法。

~~~java
package fanshe;
public class Student {
	//---------------构造方法-------------------
	//（默认的构造方法）
	Student(String str){
		System.out.println("(默认)的构造方法 s = " + str);
	}
	//无参构造方法
	public Student(){
		System.out.println("调用了公有、无参构造方法执行了。。。");
	}
	//有一个参数的构造方法
	public Student(char name){
		System.out.println("姓名：" + name);
	}
	//有多个参数的构造方法
	public Student(String name ,int age){
		System.out.println("姓名："+name+"年龄："+ age);//这的执行效率有问题，以后解决。
	}
	//受保护的构造方法
	protected Student(boolean n){
		System.out.println("受保护的构造方法 n = " + n);
	}
	//私有构造方法
	private Student(int age){
		System.out.println("私有的构造方法   年龄："+ age);
	}
}
~~~



测试类：

~~~java
package fanshe;
import java.lang.reflect.Constructor;

/*

 * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；

 * 

 * 1.获取构造方法：

 * 1).批量的方法：

 * public Constructor[] getConstructors()：所有"公有的"构造方法
      public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)

 * 2).获取单个的方法，并调用：

 * public Constructor getConstructor(Class... parameterTypes):获取单个的"公有的"构造方法：

 * public Constructor getDeclaredConstructor(Class... parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有； 		

 * 3).调用构造方法：

 * Constructor-->newInstance(Object... initargs)
    */
   public class Constructors {

   public static void main(String[] args) throws Exception {
   	//1.加载Class对象
   	Class clazz = Class.forName("fanshe.Student");
   	

   	//2.获取所有公有构造方法
   	System.out.println("**********************所有公有构造方法*********************************");
   	Constructor[] conArray = clazz.getConstructors();
   	for(Constructor c : conArray){
   		System.out.println(c);
   	}
   	
   	System.out.println("************所有的构造方法(包括：私有、受保护、默认、公有)***************");
   	conArray = clazz.getDeclaredConstructors();
   	for(Constructor c : conArray){
   		System.out.println(c);
   	}
   	
   	System.out.println("*****************获取公有、无参的构造方法*******************************");
   	Constructor con = clazz.getConstructor(null);
   	//1>、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型
   	//2>、返回的是描述这个无参构造函数的类对象。
   	System.out.println("con = " + con);
   	 
   	//调用构造方法
   	Object obj = con.newInstance();

   //	System.out.println("obj = " + obj);
   //	Student stu = (Student)obj;
   	

   	System.out.println("******************获取私有构造方法，并调用*******************************");
   	con = clazz.getDeclaredConstructor(char.class);
   	System.out.println(con);
   	//调用构造方法
   	con.setAccessible(true);//暴力访问(忽略掉访问修饰符)
   	obj = con.newInstance('男');

   }
   }
~~~



控制台输出：

**********************所有公有构造方法*********************************
public fanshe.Student(java.lang.String,int)
public fanshe.Student(char)
public fanshe.Student()
************所有的构造方法(包括：私有、受保护、默认、公有)***************
private fanshe.Student(int)
protected fanshe.Student(boolean)
public fanshe.Student(java.lang.String,int)
public fanshe.Student(char)
public fanshe.Student()
fanshe.Student(java.lang.String)
*****************获取公有、无参的构造方法*******************************
con = public fanshe.Student()
调用了公有、无参构造方法执行了。。。
******************获取私有构造方法，并调用*******************************
public fanshe.Student(char)
姓名：男


5、获取成员变量并调用：

Student类：

~~~java
package fanshe.field;

public class Student {
	public Student(){
		

	}
	//**********字段*************//
	public String name;
	protected int age;
	char sex;
	private String phoneNum;
	
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", sex=" + sex
				+ ", phoneNum=" + phoneNum + "]";
	}

}
~~~



测试类：

package fanshe.field;
import java.lang.reflect.Field;
/*
 * 获取成员变量并调用：

 * 

 * 1.批量的

 * 1).Field[] getFields():获取所有的"公有字段"

 * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；

 * 2.获取单个的：

 * 1).public Field getField(String fieldName):获取某个"公有的"字段；

 * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)

 * 

 * 设置字段的值：

 * Field --> public void set(Object obj,Object value):

 * 参数说明：

 * 1.obj:要设置的字段所在的对象；

 * 2.value:要为字段设置的值；
    */

   ~~~java
   public class Fields {
   
   	public static void main(String[] args) throws Exception {
   		//1.获取Class对象
   		Class stuClass = Class.forName("fanshe.field.Student");
   		//2.获取字段
   		System.out.println("************获取所有公有的字段********************");
   		Field[] fieldArray = stuClass.getFields();
   		for(Field f : fieldArray){
   			System.out.println(f);
   		}
   		System.out.println("************获取所有的字段(包括私有、受保护、默认的)********************");
   		fieldArray = stuClass.getDeclaredFields();
   		for(Field f : fieldArray){
   			System.out.println(f);
   		}
   		System.out.println("*************获取公有字段**并调用***********************************");
   		Field f = stuClass.getField("name");
   		System.out.println(f);
   		//获取一个对象
   		Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();
   		//为字段设置值
   		f.set(obj, "刘德华");//为Student对象中的name属性赋值--》stu.name = "刘德华"
   		//验证
   		Student stu = (Student)obj;
   		System.out.println("验证姓名：" + stu.name);
   
   
   ​		
   
   		System.out.println("**************获取私有字段****并调用********************************");
   		f = stuClass.getDeclaredField("phoneNum");
   		System.out.println(f);
   		f.setAccessible(true);//暴力反射，解除私有限定
   		f.set(obj, "18888889999");
   		System.out.println("验证电话：" + stu);
   		
   	}
   
   }
   ~~~

   

   控制台输出：

************获取所有公有的字段********************
public java.lang.String fanshe.field.Student.name
************获取所有的字段(包括私有、受保护、默认的)********************
public java.lang.String fanshe.field.Student.name
protected int fanshe.field.Student.age
char fanshe.field.Student.sex
private java.lang.String fanshe.field.Student.phoneNum
*************获取公有字段**并调用***********************************
public java.lang.String fanshe.field.Student.name
验证姓名：刘德华
**************获取私有字段****并调用********************************
private java.lang.String fanshe.field.Student.phoneNum
验证电话：Student [name=刘德华, age=0, sex=


6、获取成员方法并调用：

Student类：

~~~java
package fanshe.method;

public class Student {
	//**************成员方法***************//
	public void show1(String s){
		System.out.println("调用了：公有的，String参数的show1(): s = " + s);
	}
	protected void show2(){
		System.out.println("调用了：受保护的，无参的show2()");
	}
	void show3(){
		System.out.println("调用了：默认的，无参的show3()");
	}
	private String show4(int age){
		System.out.println("调用了，私有的，并且有返回值的，int参数的show4(): age = " + age);
		return "abcd";
	}
}
~~~



测试类：

~~~java
package fanshe.method;
import java.lang.reflect.Method;

/*

 * 获取成员方法并调用：

 * 

 * 1.批量的：

 * public Method[] getMethods():获取所有"公有方法"；（包含了父类的方法也包含Object类）

 * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)

 * 2.获取单个的：

 * public Method getMethod(String name,Class<?>... parameterTypes):

 * 参数：

 * name : 方法名；

 * Class ... : 形参的Class类型对象

 * public Method getDeclaredMethod(String name,Class<?>... parameterTypes)

 * 

 * 调用方法：

 * Method --> public Object invoke(Object obj,Object... args):

 * 参数说明：

 * obj : 要调用方法的对象；

 * args:调用方式时所传递的实参；
   ):
    */
   public class MethodClass {

   public static void main(String[] args) throws Exception {
   	//1.获取Class对象
   	Class stuClass = Class.forName("fanshe.method.Student");
   	//2.获取所有公有方法
   	System.out.println("***************获取所有的”公有“方法*******************");
   	stuClass.getMethods();
   	Method[] methodArray = stuClass.getMethods();
   	for(Method m : methodArray){
   		System.out.println(m);
   	}
   	System.out.println("***************获取所有的方法，包括私有的*******************");
   	methodArray = stuClass.getDeclaredMethods();
   	for(Method m : methodArray){
   		System.out.println(m);
   	}
   	System.out.println("***************获取公有的show1()方法*******************");
   	Method m = stuClass.getMethod("show1", String.class);
   	System.out.println(m);
   	//实例化一个Student对象
   	Object obj = stuClass.getConstructor().newInstance();
   	m.invoke(obj, "刘德华");
   	

   	System.out.println("***************获取私有的show4()方法******************");
   	m = stuClass.getDeclaredMethod("show4", int.class);
   	System.out.println(m);
   	m.setAccessible(true);//解除私有限定
   	Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参
   	System.out.println("返回值：" + result);	

   }
   }
~~~



控制台输出：

***************获取所有的”公有“方法*******************
public void fanshe.method.Student.show1(java.lang.String)
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
***************获取所有的方法，包括私有的*******************
public void fanshe.method.Student.show1(java.lang.String)
private java.lang.String fanshe.method.Student.show4(int)
protected void fanshe.method.Student.show2()
void fanshe.method.Student.show3()
***************获取公有的show1()方法*******************
public void fanshe.method.Student.show1(java.lang.String)
调用了：公有的，String参数的show1(): s = 刘德华
***************获取私有的show4()方法******************
private java.lang.String fanshe.method.Student.show4(int)
调用了，私有的，并且有返回值的，int参数的show4(): age = 20
返回值：abcd


7、反射main方法：

Student类：

package fanshe.main;

public class Student {
	public static void main(String[] args) {
		System.out.println("main方法执行了。。。");
	}
}
测试类：

~~~java
package fanshe.main;
import java.lang.reflect.Method;

/**

 * 获取Student类的main方法、不要与当前的main方法搞混了
   */
   public class Main {

   public static void main(String[] args) {
   	try {
   		//1、获取Student对象的字节码
   		Class clazz = Class.forName("fanshe.main.Student");
   		

   		//2、获取main方法
   		 Method methodMain = clazz.getMethod("main", String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型，
   		//3、调用main方法
   		// methodMain.invoke(null, new String[]{"a","b","c"});
   		 //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数
   		 //这里拆的时候将  new String[]{"a","b","c"} 拆成3个对象。。。所以需要将它强转。
   		 methodMain.invoke(null, (Object)new String[]{"a","b","c"});//方式一
   		// methodMain.invoke(null, new Object[]{new String[]{"a","b","c"}});//方式二			
   	} catch (Exception e) {
   		e.printStackTrace();
   	}

   }
}
~~~



控制台输出：

main方法执行了。。。


8、利用反射创建数值：

数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。

public static void testArray() throws ClassNotFoundException {
        Class<?> cls = Class.forName("java.lang.String");
        Object array = Array.newInstance(cls,25);
        //往数组里添加内容
        Array.set(array,0,"golang");
        Array.set(array,1,"Java");
        Array.set(array,2,"pytho");
        Array.set(array,3,"Scala");
        Array.set(array,4,"Clojure");
        //获取某一项的内容
        System.out.println(Array.get(array,3));
    }


9、反射方法的其他使用--通过反射运行配置文件内容：

Student类：

public class Student {
	public void show(){
		System.out.println("is show()");
	}
}
配置文件以txt文件为例子：

className = cn.fanshe.Student
methodName = show
测试类：

~~~java
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Properties;

/*

 * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改

 * 我们只需要将新类发送给客户端，并修改配置文件即可
   */
   public class Demo {
   public static void main(String[] args) throws Exception {
   	//通过反射获取Class对象
   	Class stuClass = Class.forName(getValue("className"));//"cn.fanshe.Student"
   	//2获取show()方法
   	Method m = stuClass.getMethod(getValue("methodName"));//show
   	//3.调用show()方法
   	m.invoke(stuClass.getConstructor().newInstance());
   	
   }

   //此方法接收一个key，在配置文件中获取相应的value
   public static String getValue(String key) throws IOException{
   	Properties pro = new Properties();//获取配置文件的对象
   	FileReader in = new FileReader("pro.txt");//获取输入流
   	pro.load(in);//将流加载到配置文件对象中
   	in.close();
   	return pro.getProperty(key);//返回根据key获取的value值
   }
   }
~~~



控制台输出：

~~~java
is show()
~~~



需求：

当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动。

~~~java
public class Student2 {
	public void show2(){
		System.out.println("is show2()");
	}
}
~~~



配置文件更改为：

~~~java
className = cn.fanshe.Student2
methodName = show2
~~~



10、反射方法的其他使用--通过反射越过泛型检查：

泛型用在编译期，编译过后泛型擦除（消失掉），所以是可以通过反射越过泛型检查的

测试类：

```java
import java.lang.reflect.Method;
import java.util.ArrayList;

/*

 * 通过反射越过泛型检查
 * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？
   */
   public class Demo {
   public static void main(String[] args) throws Exception{
   	ArrayList<String> strList = new ArrayList<>();
   	strList.add("aaa");
   	strList.add("bbb");
   	
   //	strList.add(100);
   	//获取ArrayList的Class对象，反向的调用add()方法，添加数据
   	Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象
   	//获取add()方法
   	Method m = listClass.getMethod("add", Object.class);
   	//调用add()方法
   	m.invoke(strList, 100);
   	
        //遍历集合
        for(Object obj : strList){
            System.out.println(obj);
        }
    }
}		
```

控制台输出：

~~~
aaa
bbb
100
~~~



### 1.4 JVM虚拟机

### 1.5 GC回收机制



## 二：进阶类

### 2.1 设计模式

### 2.2 业务实战

#### 2.2.1 秒杀业务实现

所需使用pom-jar包

~~~xml
<!--    集成Redis服务    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-redis</artifactId>
    <version>1.4.1.RELEASE</version>
</dependency>

<!--   etttuce作为redis的桥接工具     -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
~~~



  1.模拟并发500 秒杀服务类

~~~java
 /**
     *  集成秒杀抽象类
     */
    @Override
    public ResultCc secKill(String json, HttpServletRequest request) {

        if(CheckUtil.checkIsNullAndEmpty(json)){

            //获取到json内对应的信息
            JSONObject jsonObject = JSONObject.parseObject(json);

            //获取用户信息
            jsonObject.getString("userId");
            //获取商品ID
            String seckillId = jsonObject.getString("seckillId");
            String methodType = jsonObject.getString("methodType");

            try {
                for (int i = 0; i < 500; i++) {
                    Runnable runnable = new Runnable() {
                        @Override
                        public void run() {
                            //秒杀
                            cpSeckillService.miaoshaGoods(jsonObject);
                        }
                    };
                    threadPoolExecutor.execute(runnable);
                }



            }catch (Exception e){
                e.printStackTrace();
                return ResultCc.error("抢购失败", "当前抢购的人数太多了！");
            }

            return ResultCc.succes();

        }else{
           return ResultCc.errorOfParamUnValid();
        }
    }

~~~

2. 业务底层实现类

   ~~~java
    /**
       *@Description:  处理秒杀业务
       *@Parameter:[methodType, id]
       *@Return:com.cpos.cposconcurrent.entiry.ResultCc
       *@Author:leiwenlong
       *@Date:2021/6/17
       **/
       @Override
       public ResultCc miaoshaGoods(JSONObject jsonObject) {
   
           String seckillId = jsonObject.getString("seckillId");
           int seckillIdInt = Integer.parseInt(seckillId);
           String methodType = jsonObject.getString("methodType");
           int methodTypeInt = Integer.parseInt(methodType);
           //校验参数是否全
           if(CheckUtil.checkIsNullAndEmpty(methodType) && CheckUtil.checkIsNullAndEmpty(seckillIdInt)){
   
               int countSuc=0;
               ResultCc error = ResultCc.error("抢购失败");
   
               //通过方法实现不同业务
               switch (methodTypeInt){
                   //普通无处理秒杀处理
                   case 1:
                       if (toSeckill(seckillIdInt)){ return error;}
                       break;
                   case 2:
                       //乐观锁处理的高并发秒杀实现
                       break;
                   case 3:
                       //悲观锁处理的高并发秒杀实现
                       break;
                   case 4:
                       //线程同步锁处理的高并发秒杀实现
                       synchronized (this){
                           if (toSeckill(seckillIdInt)){ return error;}
                       }
                       break;
                   case 5:
                       //线程可重入锁处理的高并发秒杀实现
                       lock.lock();
                       if (toSeckill(seckillIdInt)){ return error;}
                       lock.unlock();
                       break;
                   case 6:
                       //redis实现秒杀
                       CpSeckill seckill = cpSeckillMapper.selectById(seckillIdInt);
                       //增量计算剩余库存(利用redis的单线程特性)
                       //redisTemplate.opsForValue().increment(seckill.getName()+":goodsSum",-1);
                       //采用分布式集群方式
                       HostAndPort hostAndPort = new HostAndPort("101.37.145.206", 6379);
                       Set<HostAndPort> hostAndPortSet = new HashSet<>();
                       hostAndPortSet.add(hostAndPort);
                       JedisCluster jedis = new JedisCluster(hostAndPortSet);
                       double goodsSurplusSum = jedis.incrBy(seckill.getName()+":goodsSum",-1);
                       if(goodsSurplusSum>=0){
                           if (toSeckill(seckillIdInt)){ return error;}
                           System.out.println("秒杀成功！");
                       }else{
                           System.out.println("秒杀失败！");
                       }
                       break;
                   case 7:
                       //使用线程池来限定秒杀次数 以此来确保秒杀精准性
                       break;
               }
           }else{
               return ResultCc.error("参数不足");
           }
           return null;
       }
   
       private boolean toSeckill(Integer id) {
           int countSuc;//1.获取秒杀商品
           CpSeckill seckill = cpSeckillMapper.selectById(id);
           //获取库存
           Integer seckillNum = seckill.getSeckillNum();
           if(seckillNum > 0 ){
               //减去库存
               seckill.setSeckillNum(seckillNum - 1);
               //执行修改方法
               countSuc = cpSeckillMapper.updateById(seckill);
               outMethod(countSuc);
           }else{
               return true;
           }
           return false;
       }
   
       private void outMethod(int countSuc) {
           if(countSuc==1){
               System.out.println("秒杀成功！");
           }else{
               System.out.println("秒杀失败！");
           }
       }
   ~~~

   

## 三：框架类

### 3.1  Spring 

#### 3.1.1 概述

   Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。

  Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。

#### 3.1.2 Spring 架构

- A 表现层  web层  MVC是表现层的一个设计模型 

- B 业务层 service层

- C 持久层 dao层

#### 3.1.3  Spring 特效

- 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API
- 控制反转：IOC——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。
- 依赖注入：DI——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。
- 面向切面编程：Aspect Oriented Programming——AOP
- 容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期
- 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。
- 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表述层的 SpringMVC 和持久层的 Spring JDBC）

#### 3.1.4 Spring 核心

##### 3.1.4.1 AOP面向切面

```
Spring 框架的一个关键组件是面向切面的程序设计（AOP）框架。一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。方便解耦
```

##### 3.1.4.2 DI 依赖注入

```xml
Spring 最认同的技术是控制反转的依赖注入（DI）模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。
当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。
```

#### 3.1.5 Sprig组件

![Spring 体系结构](https://atts.w3cschool.cn/attachments/image/20181023/1540290875453691.png)

#### 3.1.6 数据访问/集成

数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：

（注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）

- **JDBC** 模块提供了 JDBC 抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析。
- **ORM** 模块提供了对流行的对象关系映射 API 的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring的其它功能整合，比如前面提及的事务管理。
- **OXM** 模块提供了对 OXM 实现的支持，比如 JAXB、Castor、XML Beans、JiBX、XStream 等。
- **JMS** 模块包含生产（produce）和消费（consume）消息的功能。从 Spring 4.1 开始，集成了 spring-messaging 模块。
- **事务**模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写 beginTransaction()、commit()、rollback() 等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务力度更细）

https://www.w3cschool.cn/wkspring/

### 3.2  Mybatis

### 3.3  Spring mvc

### 3.4  Hibernate

### 3.5  SpringBoot

#### 3.5.1 SpringBoot 配置

```yaml
server:
  port: 8080
  servlet:
    context-path: /cpos
    compression:
      enabled: true
      mime-types: application/javascript,application/json,application/xml,text/html,text/xml,text/plain,text/css,image/*
spring:
  resources:
    static-locations: classpath:/static/
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 100MB
  datasource:
    driver-class-name:
    #本地数据库
    url: jdbc:mysql://127.0.0.1:3306/cpos?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC
    username: root
    password: lwl135
    type:
```

#### 3.5.2 环境搭建

  https://start.spring.io/      搭建Springboot demo项目

![image-20201129232723081](C:\Users\lei41\AppData\Roaming\Typora\typora-user-images\image-20201129232723081.png)

 IDEA创建 SpringBoot项目

![image-20201129232844361](C:\Users\lei41\AppData\Roaming\Typora\typora-user-images\image-20201129232844361.png)



#### 3.5.3 SpringBoot 格式统一

  RestFul风格  例如： localhost:8080/cpos/api/test/con1

#### 3.5.4 SpringBoot 统一拦截器

https://www.w3cschool.cn/springboot

#### 3.5.5 SpringBoot 常用注解详解

##### @ControllerAdvice

很多初学者可能都没有听说过这个注解，实际上，这是一个非常有用的注解，顾名思义，这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：

1. 全局异常处理
2. 全局数据绑定
3. 全局数据预处理

灵活使用这三个功能，可以帮助我们简化很多工作，需要注意的是，这是 SpringMVC 提供的功能，在 Spring Boot 中可以直接使用，下面分别来看

###### 全局异常处理

使用 @ControllerAdvice 实现全局异常处理，只需要定义类，添加该注解即可定义方式如下：

~~~java
@ControllerAdvice
public class MyGlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ModelAndView customException(Exception e) {
        ModelAndView mv = new ModelAndView();
        mv.addObject("message", e.getMessage());
        mv.setViewName("myerror");
        return mv;
    }
}
~~~

在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法...，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。

@ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来。

###### 全局数据绑定

全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。

使用步骤，首先定义全局数据，如下：

~~~java
@ControllerAdvice
public class MyGlobalExceptionHandler {
    @ModelAttribute(name = "md")
    public Map<String,Object> mydata() {
        HashMap<String, Object> map = new HashMap<>();
        map.put("age", 99);
        map.put("gender", "男");
        return map;
    }
}
~~~

使用 @ModelAttribute 注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。

定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：

~~~java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String hello(Model model) {
        Map<String, Object> map = model.asMap();
        System.out.println(map);
        int i = 1 / 0;
        return "hello controller advice";
    }
}
~~~

###### 全局数据预处理

考虑我有两个实体类，Book 和 Author，分别定义如下：

~~~java
public class Book {
    private String name;
    private Long price;
    //getter/setter
}
public class Author {
    private String name;
    private Integer age;
    //getter/setter
}
~~~

此时，如果我定义一个数据添加接口，如下：

~~~java
@PostMapping("/book")
public void addBook(Book book, Author author) {
    System.out.println(book);
    System.out.println(author);
}
~~~

这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过 @ControllerAdvice 的全局数据预处理可以解决这个问题

解决步骤如下:

1.给接口中的变量取别名

~~~java
@PostMapping("/book")
public void addBook(@ModelAttribute("b") Book book, @ModelAttribute("a") Author author) {
    System.out.println(book);
    System.out.println(author);
}
~~~

2.进行请求数据预处理
在 @ControllerAdvice 标记的类中添加如下代码:

~~~java
@InitBinder("b")
public void b(WebDataBinder binder) {
    binder.setFieldDefaultPrefix("b.");
}
@InitBinder("a")
public void a(WebDataBinder binder) {
    binder.setFieldDefaultPrefix("a.");
}
~~~

@InitBinder("b") 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀.

3.发送请求

请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.

![img](https://www.javaboy.org/images/boot/5-1.png)

### 3.6  SpringCloud

https://www.springcloud.cc/spring-cloud-config.html

#### 3.6.1 组件介绍

​    Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。

##### 3.6.1.1 服务发现——Netflix Eureka

  一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。

##### 3.6.1.2 客服端负载均衡——Netflix Ribbon

Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。下面是用到的一些负载均衡策略：

- 简单轮询负载均衡
- 加权响应时间负载均衡
- 区域感知轮询负载均衡
- 随机负载均衡

Ribbon中还包括以下功能：

- 易于与服务发现组件（比如Netflix的Eureka）集成
- 使用Archaius完成运行时配置
- 使用JMX暴露运维指标，使用Servo发布
- 多种可插拔的序列化选择
- 异步和批处理操作（即将推出）
- 自动SLA框架（即将推出）
- 系统管理/指标控制台（即将推出）

##### 3.6.1.3 断路器——Netflix Hystrix

​    断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。



   断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。

![img](https://upload-images.jianshu.io/upload_images/13418826-e3a53f6ab0e51889.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

##### 3.6.1.4 服务网关——Netflix Zuul	

类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。

##### 3.6.1.5 分布式配置——Spring Cloud Config

![img](https://upload-images.jianshu.io/upload_images/13418826-842214bc1df8f310.png?imageMogr2/auto-orient/strip|imageView2/2/w/498/format/webp)

这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新

##### 3.6.1.6 微服务网关getway

  Spring cloud gateway是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。

  推荐文章：https://blog.csdn.net/squirrelanimal0922/article/details/90517946

#### 3.6.2 实战应用

### 3.7 Sentinel 

#### 是什么

随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。



#### 如何工作

Sentinel 的主要工作机制如下：

- 对主流框架提供适配或者显示的 API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。
- 根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel 提供开放的接口，方便您定义及改变规则。
- Sentinel 提供实时的监控系统，方便您快速了解目前系统的状态



#### 相比Hystrix



#### 相同

Sentinel 和 Hystrix 的原则是一致的: 当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。



#### 不同点

在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。

Hystrix 通过 [线程池隔离](https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FNetflix%2FHystrix%2Fwiki%2FHow-it-Works%23benefits-of-thread-pools) 的方式，来对依赖（在 Sentinel 的概念中对应 *资源*）进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（过多的线程池导致线程数目过多），还需要预先给各个资源做线程池大小的分配。

Sentinel 对这个问题采取了两种手段:

- 通过并发线程数进行限制

和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。

- 通过响应时间对资源进行降级

除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。



#### Sentinel 控制台

Sentinel 提供一个轻量级的开源控制台，它提供机器发现以及健康情况管理、监控（单机和集群），规则管理和推送的功能。另外，鉴权在生产环境中也必不可少

文档地址：[https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0](https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Falibaba%2FSentinel%2Fwiki%2F%E6%8E%A7%E5%88%B6%E5%8F%B0)



#### 如何使用

这里介绍了怎么使用到我们项目中的文档，相当详细，阿里的开源做的很好

[https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8](https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Falibaba%2FSentinel%2Fwiki%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8)



##### windos下安装sentinel 

###### 下载：

下载地址：https://github.com/alibaba/Sentinel/releases

下载会很慢，下面给出下载地址

链接：https://pan.baidu.com/s/1nQ9VlxYItAhuAYYXSp22gQ 
提取码：ql72



在本地用下面命令启动  java -jar (sentinel-dashboard-jar包)



浏览器访问 http://localhost:8858/

用户名和密码都是 sentinel

### 3.8  nacos 

##### windows下安装nacos

1、下载
下载地址：https://github.com/alibaba/nacos/releases/tag/1.1.0

选择这个zip下载。

下载完毕后我们可以看看目录结构：



这里的bin目录里面有windows启动文件startup.cmd，我们双击就能启动了，和大多数windows进程类似。

启动后会有一个cmd窗口去打印命令并启动。



这里我们启动成功了，启动失败后窗口会一闪而过。

2、访问
访问地址：http://localhost:8848/nacos/index.html

用户名密码：nacos/nacos



##### linux下安装nacos

- 下载地址[.tar.gz] https://github.com/alibaba/nacos/releases

- ~~~
  tar -zxvf nacos-server-1.1.4.tar.gz 
  mv nacos /usr/local
  
  ~~~

- 单机模式启动 

- ~~~
  cd /usr/local/nacos/bin
  sh startup.sh -m standalone
  ~~~

- 启动

- ~~~
  bash startup.sh -m standalone
  ~~~

- 启动时报错

- 错误一

- ~~~
  /usr/java/jdk1.8.0_181/bin/java  -Xms512m -Xmx512m -Xmn256m -Dnacos.standalone=true -Djava.ext.dirs=/usr/java/jdk1.8.0_181/jre/lib/ext:/usr/java/jdk1.8.0_181/lib/ext:/usr/local/nacos/plugins/cmdb:/usr/local/nacos/plugins/mysql -Xloggc:/usr/local/nacos/logs/nacos_gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 -Dnacos.home=/usr/local/nacos -Dloader.path=/usr/local/nacos/plugins/health -jar /usr/local/nacos/target/nacos-server.jar  --spring.config.location=classpath:/,classpath:/config/,file:./,file:./config/,file:/usr/local/nacos/conf/ --logging.config=/usr/local/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288
  nacos is starting with standalone
  nacos is starting，you can check the /usr/local/nacos/logs/start.out
  
  ~~~

  查看/usr/local/nacos/logs/start.out,看文件中提示具体什么错误

  如报下面错误：

  ~~~java
  java.io.FileNotFoundException: /usr/local/nacos/conf/cluster.conf (没有那个文件或目录)
  	at java.io.FileInputStream.open0(Native Method)
  	at java.io.FileInputStream.open(FileInputStream.java:195)
  	at java.io.FileInputStream.<init>(FileInputStream.java:138)
  	at com.alibaba.nacos.core.utils.SystemUtils.readClusterConf(SystemUtils.java:124)
  	at com.alibaba.nacos.core.listener.StartingSpringApplicationRunListener.logClusterConf(StartingSpringApplicationRunListener.java:141)
  	at com.alibaba.nacos.core.listener.StartingSpringApplicationRunListener.contextPrepared(StartingSpringApplicationRunListener.java:91)
  	at org.springframework.boot.SpringApplicationRunListeners.contextPrepared(SpringApplicationRunListeners.java:60)
  	at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:374)
  	at org.springframework.boot.SpringApplication.run(SpringApplication.java:314)
  	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260)
  	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248)
  	at com.alibaba.nacos.Nacos.main(Nacos.java:33)
  	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  	at java.lang.reflect.Method.invoke(Method.java:498)
  	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)
  	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)
  	at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)
  	at org.springframework.boot.loader.PropertiesLauncher.main(PropertiesLauncher.java:593)
  
  
  ~~~

  解决方案

  - 由于启动的默认由cluster改成了standalone单机启动模式，但是启动仍然是集群模式启动，并且抛出上述找不到cluster.conf文件

  - ~~~
    bash startup.sh -m standalone
    
    ~~~

  - 错误二

  - ~~~
    systemctl start nacos.service
    
    ~~~

  - 报如下错误

    ~~~
    nacos.service
       Loaded: loaded (/usr/lib/systemd/system/nacos.service; bad; vendor preset: disabled)
       Active: failed (Result: exit-code) since 一 2019-10-28 22:31:25 CST; 19s ago
      Process: 2847 ExecStart=/usr/local/nacos/bin/startup.sh -m standalone (code=exited, status=1/FAILURE)
    
    10月 28 22:31:25 localhost.localdomainP1 startup.sh[2847]: which: no javac in (/usr/...
    10月 28 22:31:25 localhost.localdomainP1 startup.sh[2847]: readlink: 缺少操作数
    10月 28 22:31:25 localhost.localdomainP1 startup.sh[2847]: Try 'readlink --help' for...
    10月 28 22:31:25 localhost.localdomainP1 systemd[1]: nacos.service: control process...1
    10月 28 22:31:25 localhost.localdomainP1 startup.sh[2847]: dirname: 缺少操作数
    10月 28 22:31:25 localhost.localdomainP1 startup.sh[2847]: Try 'dirname --help' for ...
    10月 28 22:31:25 localhost.localdomainP1 systemd[1]: Failed to start nacos.service.
    10月 28 22:31:25 localhost.localdomainP1 startup.sh[2847]: ERROR: Please set the JAV...
    10月 28 22:31:25 localhost.localdomainP1 systemd[1]: Unit nacos.service entered fai....
    10月 28 22:31:25 localhost.localdomainP1 systemd[1]: nacos.service failed.
    
    ~~~

    #### 解决方案

    需要更改相应启动文件的JDK配置
    将如下三行注释掉，并将第一行的配置修改为JDK的位置。

    如何找到JDK位置

    ~~~
    whereis java
    ~~~

    找到JDK的位置为: /usr/java/jdk1.8.0_181

    ~~~
    vim startup.sh
    
    ~~~

    原文

    ~~~
    [ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=$HOME/jdk/java
    [ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/usr/java
    [ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/opt/taobao/java
    [ ! -e "$JAVA_HOME/bin/java" ] && unset JAVA_HOME
    
    
    ~~~

    修改后

    ~~~
    [ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/usr/java/jdk1.8.0_181
    #[ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/usr/java
    #[ ! -e "$JAVA_HOME/bin/java" ] && JAVA_HOME=/opt/taobao/java
    #[ ! -e "$JAVA_HOME/bin/java" ] && unset JAVA_HOME
    
    
    
    ~~~

    

访问web地址

~~~
curl http://127.0.0.1:8848/nacos/index.html
~~~

http://127.0.0.1:8848/nacos/index.html
登录的用户名和密码默认的都是nacos



###### 注意防火墙的端口8848

集群

本例的安装目录为/usr/local/nacos

参考链接： https://www.cnblogs.com/lhlucky/p/nacoscluster.html

###### 1.配置 cluster.conf文件

- 在文件里添加相关服务器IP，三台机器都做相同的配置

- ~~~
  cd /usr/local/nacos/conf
  cp cluster.conf.example cluster.conf
  vim cluster.conf
  
  ~~~

- cluster.conf文件内容为：

- ~~~
  #it is ip
  #example
  #10.10.109.214
  #11.16.128.34
  #11.16.128.36
  192.168.47.128:8848
  192.168.47.129:8848
  192.168.47.130:8848
  
  ~~~

- ###### 2.创建数据库

- 脚本位置 /usr/local/nacos/conf/nacos-mysql.sql

- 将脚本里的SQL语句直接导入既可

- ###### 3.配置application.properties

- ~~~
  cd /usr/local/nacos/conf
  vim application.properties
  
  ~~~

- 增加内容为:

- ~~~
  spring.datasource.platform=mysql
  db.num=1
  db.url.0=jdbc:mysql://192.168.47.128:5186/nacos_config?serverTimezone=GMT%2B8&characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
  db.user=cici
  db.password=123123
  
  
  ~~~

- ###### 4.分别启动三台服务器

  ~~~
  cd /usr/local/nacos/bin
  sh startup.sh
  
  ~~~

  

- 观察日志,看是否有异常打印【cat或者tailf命令】

  /usr/local/nacos/logs/nacos.log
  /usr/local/nacos/logs/naming-raft.log
  /usr/local/nacos/logs/start.out
  启动成功后访问，观察集群

  http://192.168.47.128:8848/nacos/index.html

  http://192.168.47.129:8848/nacos/index.html

  http://192.168.47.130:8848/nacos/index.html

- ###### 5.遇到的问题一

###### 5.1 mysql8问题

直接下载的稳定版本nacos编译后的文件，不支持mysql8及其以上版本，本例中使用的为1.1.4版本

-参考链接
https://www.cnblogs.com/gyli20170901/p/11245270.html

###### 解决方案

下载nacos的源码并更改mysql驱动的版本

###### 5.1.1 下载地址

https://github.com/alibaba/nacos

###### 5.1.2 修改

修改最外层pom.xml 中 mysql驱动版本，我这边使用的是8.0.16

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.16</version>
</dependency>

###### 5.1.3 修改naming这个项目 com.alibaba.nacos.naming.healthcheck 包下的 MysqlHealthCheckProcessor 类的第24行导包为

import com.mysql.cj.jdbc.MysqlDataSource;


###### 5.1.4修改console项目下的配置文件

-由于mysql8及其以上版本需要带时区，所以还需要修改 console这项目 resources/META-INF下 nacos-default.properties这个文件中的db.url



~~~
db.url.0=jdbc:mysql://11.162.196.161:3306/diamond_devtest?serverTimezone=GMT%2B8&characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
db.url.1=jdbc:mysql://11.163.152.91:3306/diamond_devtest?serverTimezone=GMT%2B8&characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
~~~



###### 5.1.5 打包

cmd命令窗口进入项目根目录执行

mvn -Prelease-nacos clean install -U


###### 5.1.6 打包完成后，再次安装nacos，步骤按照上面安装的说明

包的地址[根目录\distribution\target]

###### 5.1.7 再次修改application.properties配置文件

~~~
cd /usr/local/nacos/conf
vim application.properties
~~~



修改为

~~~
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://192.168.47.128:5186/nacos_config?serverTimezone=GMT%2B8&characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
db.user=cici
db.password=123123
~~~





###### 5.2 unable to find local peer: 192.168.47.128:8848

~~~java
java.lang.IllegalStateException: unable to find local peer: 172.16.26.250:8848, all peers: [120.79.167.88:8848, 119.23.104.130:8848, 47.101.47.127:8848]
	at com.alibaba.nacos.naming.consistency.persistent.raft.RaftPeerSet.local(RaftPeerSet.java:224)
	at com.alibaba.nacos.naming.monitor.PerformanceLoggerThread.collectMetrics(PerformanceLoggerThread.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:84)
	at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)
	at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:93)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
2019-10-18 14:06:45,000 ERROR Unexpected error occurred in scheduled task.
~~~






因为我部署的三台服务器是虚拟机上的，属于内网，都是在一个网段的。

解决方案

编辑启动文件 /usr/local/nacos/bin/startup.sh

~~~
vim /usr/local/nacos/bin/startup.sh
~~~



依次修改三台服务器的启动文件

###### 单机模式对应的启动参数
~~~
if [[ "${MODE}" == "standalone" ]]; then
    JAVA_OPT="${JAVA_OPT} -Xms512m -Xmx512m -Xmn256m"
    JAVA_OPT="${JAVA_OPT} -Dnacos.standalone=true"
else
~~~



###### 集群模式对应的启动参数
    JAVA_OPT="${JAVA_OPT} -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"
    JAVA_OPT="${JAVA_OPT} -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${BASE_DIR}/logs/java_heapdump.hprof"
    JAVA_OPT="${JAVA_OPT} -XX:-UseLargePages"
    
    # *新增以下参数设置本机ip地址*
    JAVA_OPT="${JAVA_OPT} -Dnacos.server.ip=192.168.47.128"

~~~
fi

if [[ "${FUNCTION_MODE}" == "config" ]]; then
    JAVA_OPT="${JAVA_OPT} -Dnacos.functionMode=config"
elif [[ "${FUNCTION_MODE}" == "naming" ]]; then
    JAVA_OPT="${JAVA_OPT} -Dnacos.functionMode=naming"
fi
~~~



修改之后再次启动即可

#关闭服务

~~~
cd /usr/local/nacos/bin
./shutdown.sh
~~~



#启动服务

~~~
sh startup.sh
~~~



## 四：业务类

### 4.1  金融业务

### 4.2  社交业务

### 4.3  医疗业务

### 4.4  政务业务

### 4.5  电商业务

## 五：中间件

### 5.1 ActiveMQ

#### 5.1.1 概述

​    ActiveMQ是Apache所提供的一个开源的消息系统，完全采用Java来实现，因此，它能很好地支持J2EE提出的JMS（Java Message Service,即Java消息服务）规范。JMS是一组Java应用程序接口，它提供消息的创建、发送、读取等一系列服务。JMS提供了一组公共应用程序接口和响应的语法，类似于Java数据库的统一访问接口JDBC,它是一种与厂商无关的API，使得Java程序能够与不同厂商的消息组件很好地进行通信。

#### 5.1.2  JMS简介

JMS支持两种消息发送和接收模型。

- 一种称为P2P(Ponit to Point)模型，即采用点对点的方式发送消息。P2P模型是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输称为可能，P2P模型在点对点的情况下进行消息传递时采用。

- ![img](https://upload-images.jianshu.io/upload_images/3110861-d5903d5c31002368.png)

- 另一种称为Pub/Sub(Publish/Subscribe，即发布-订阅)模型，发布-订阅模型定义了如何向一个内容节点发布和订阅消息，这个内容节点称为topic(主题)。主题可以认为是消息传递的中介，消息发布这将消息发布到某个主题，而消息订阅者则从主题订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布-订阅模型在消息的一对多广播时采用。

- ![img](https://upload-images.jianshu.io/upload_images/3110861-78a5559c4f70ee40.png)

  #### 5.1.3 JMS术语

  - Provider/MessageProvider：生产者
  - Consumer/MessageConsumer：消费者
  - PTP：Point To Point，点对点通信消息模型
  - Pub/Sub：Publish/Subscribe，发布订阅消息模型
  - Queue：队列，目标类型之一，和PTP结合
  - Topic：主题，目标类型之一，和Pub/Sub结合
  - ConnectionFactory：连接工厂，JMS用它创建连接
  - Connnection：JMS Client到JMS Provider的连接
  - Destination：消息目的地，由Session创建
  - Session：会话，由Connection创建，实质上就是发送、接受消息的一个线程，因此生产者、消费者都是Session创建的

#### 5.1.4  Window下安装ActiveMQ

​    1、下载地址：http://activemq.apache.org/download-archives.html ，本文用的是windows版的5.15.3版本，下载下来是压缩包。[apache-activemq-5.15.3-bin.zip](http://archive.apache.org/dist/activemq/5.15.3/apache-activemq-5.15.3-bin.zip) 

​    2、将压缩包解压一个到目录下，CMD进入到解压目录下的bin目录下，执行 activemq.bat start 启动。  如果能成功访问 http://localhost:8161/admin（用户名和密码默认为admin），则启动成功。

#### 5.1.5   ActiveMq集成项目

```xml
<!--ActiveMq-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-activemq</artifactId>
            <version>1.5.0.RELEASE</version>
        </dependency>
        <!--消息队列连接池-->
        <dependency>
            <groupId>org.apache.activemq</groupId>
            <artifactId>activemq-pool</artifactId>
            <version>5.15.0</version>
        </dependency>
```

   topic模式有普通订阅和持久化订阅

普通订阅：在消费者启动之前发送过来的消息，消费者启动之后不会去消费；

持久化订阅： 在消费者启动之前发送过来的消息，消费者启动之后会去消费

### 5.2 RebbitMQ

特点

- 开源、性能优秀，稳定性保障
- 提供可靠性消息投递模式、返回模式
- 与Spring AMQP完美整合，API丰富
- 集群模式丰富，表达式配置，HA模式，镜像队列模型
- 保证数据不丢失的前提做到高可靠性、可用性



MQ典型应用场景：

- 异步处理。把消息放入消息中间件中，等到需要的时候再去处理。
- 流量削峰。例如秒杀活动，在短时间内访问量急剧增加，使用消息队列，当消息队列满了就拒绝响应，跳转到错误页面，这样就可以使得系统不会因为超负载而崩溃。
- 日志处理
- 应用解耦。假设某个服务A需要给许多个服务（B、C、D）发送消息，当某个服务（例如B）不需要发送消息了，服务A需要改代码再次部署；当新加入一个服务（服务E）需要服务A的消息的时候，也需要改代码重新部署；另外服务A也要考虑其他服务挂掉，没有收到消息怎么办？要不要重新发送呢？是不是很麻烦，使用MQ发布订阅模式，服务A只生产消息发送到MQ，B、C、D从MQ中读取消息，需要A的消息就订阅，不需要了就取消订阅，服务A不再操心其他的事情，使用这种方式可以降低服务或者系统之间的耦合。



提到RabbitMQ，就不得不提AMQP协议。AMQP协议是具有现代特征的二进制协议。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。

先了解一下AMQP协议中间的几个重要概念：

- Server：接收客户端的连接，实现AMQP实体服务。
- Connection：连接，应用程序与Server的网络连接，TCP连接。
- Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。
- Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。
- Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。
- Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。
- Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。
- RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”。
- Queue：消息队列，用来保存消息，供消费者消费。

![img](https://img2018.cnblogs.com/blog/1538609/201907/1538609-20190720105435977-1170222541.png)

- 我选择3.8.0-beta.4-management进行安装，带有management是含有管理界面的。
- 拉取镜像和启动：`docker run -d --hostname my-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3.8.0-beta.4-management`
- 查看镜像：

```
[root@localhost ~]# docker images
REPOSITORY              TAG                       IMAGE ID            CREATED             SIZE
docker.io/rabbitmq      3.8.0-beta.4-management   d0f93d2b83f7        3 days ago          180 MB
```

- 打开浏览器访问localhost:15672，如果你和我一样装在虚拟机上面的话，需要打开虚拟机ip:15672
- ![img](https://img2018.cnblogs.com/blog/1538609/201907/1538609-20190720105925148-289286470.png)
- 进行填写账号密码：默认账号密码都是guest.
- ![img](https://img2018.cnblogs.com/blog/1538609/201907/1538609-20190720105939506-1976176866.png)

到此，RabbitMQ已经安装并运行起来了。

在这个界面里面我们可以做些什么？
可以手动创建虚拟host，创建用户，分配权限，创建交换机，创建队列等等，还有查看队列消息，消费效率，推送效率等等。

以上这些管理界面的操作在这篇暂时不做扩展描述，我想着重介绍后面实例里会使用到的。

首先先介绍一个简单的一个消息推送到接收的流程，提供一个简单的图：



### ![img](https://img-blog.csdnimg.cn/20190903141227300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mzg3OTQw,size_16,color_FFFFFF,t_70)





https://blog.csdn.net/qq_35387940/article/details/100514134

rabbit+springboot集成 https://blog.csdn.net/qq_35387940/article/details/100514134

### 5.3 Dubbo

特性

- 面向接口代理的高性能RPC调用

  提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节。

- 智能负载均衡

  内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。

- 服务自动注册与发现

  支持多种注册中心服务，服务实例上下线实时感知。

- 高度可扩展能力

  遵循微内核+插件的设计原则，所有核心能力如Protocol、Transport、Serialization被设计为扩展点，平等对待内置实现和第三方实现。

- 运行期流量调度

  内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能。

- 可视化的服务治理与运维

  提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。

#### 5.3.1 SpringBoot集成Dubbo/ZooKeeper

  Dubbo 不单单只是高性能的 RPC 调用框架，更是 SOA 服务治理的一种方案。

**核心**：

1. 远程通信，向本地调用一样调用远程方法。

2. 集群容错

3. 服务自动发现和注册，可平滑添加或者删除服务提供者。

我们常常使用 Springboot 暴露 HTTP 服务，并走 JSON 模式。但慢慢量大了，一种 SOA 的治理方案。这样可以暴露出 Dubbo 服务接口，提供给 Dubbo 消费者进行 RPC 调用。下面我们详解下如何集成 Dubbo。

   ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

#### 5.3.2 Dubbo下载与配置

（1）dubbo-admin-2.5.x.war官网下载： 

**dubbo源码提供了两个下载地址，一个是dubbo官网，一个是GitHub上，我们推荐从GitHub上下载。**

原因：

dubbo官网提供的源码版本，都是2.6版本之后的源码，没有2.6版本之前的源码，而2.6之后的版本，主要是提供给springboot使用的，如果我们没有使用使用springboot整合dubbo，那么不建议使用2.6之后的版本，一般使用2.5.3版本的比较多，此版本比较稳定。

还有一个问题，2.6之后的版本，并没有提供dubbo-admin（管理控制台），dubbo-monitor-simple（简易监控中心），dubbo-registry-simple（简易注册中心）等war包



**将它解压，放入到tomcat的webapps目录下，结构如图：**

**（3）由于我的tomcat在用，所以我弄了一个新的tomcat，值得注意的是：tomcat默认端口号8080已经在旧tomcat用了，所以这里需要更改一下新toncat配置，修改一下端口号即可。打开 tomcat目录的conf下的 server.xml 文件。**



**注意顺序：先启动zk，再启动tomcat，再浏览器访问。浏览器输入密码：默认root，root。**



**（1）先启动zk，用管理员方式打开cmd窗口，进入到zk的bin目录然后命令：zkServer.cmd 。也可以直接双击zkServer,不过可能闪退，网上很多解决方法。**



启动tomcat后

**打开浏览器，地址栏输入：http://localhost:8100/dubbo-admin/ (这是我的)，dubbo默认root。**



**（4）**修改Dubbo-admin登录用户名和密码。

进入dubbo-admin的WEB-INF 下的dubbo.properties

dubbo.admin.root.password=root

的意思是用户名为root 密码为root

dubbo.admin.guest.password=guest

的意思是用户名为guest密码为guest

![image-20210907095316704](C:\Users\lei41\AppData\Roaming\Typora\typora-user-images\image-20210907095316704.png)

### 5.4 Zookeeper

zookeeper是一个注册中心

#### linux安装zookeeper及使用

##### 一、安装条件

想要安装zookeeper，必须先在linux中安装好jdk。安装步骤见：

https://www.cnblogs.com/expiator/p/9987351.html

##### 二、下载并解压zookeeper压缩包

\1. 先进入/usr/local/目录，也可以是其他的目录：

```
[root@localhost /]# cd /usr/local
```

\2. zookeeper安装包可以在官网下载。

也可以在后面这个地址下载 http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz

如果链接打不开，就先打开 [http://mirror.bit.edu.cn/apache/zookeeper ](http://mirror.bit.edu.cn/apache/zookeeper/)， 再选择版本。

在此目录下载zookeeper安装包：

```
[root@localhost local]# wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz 
```

\3. 解压：

```
[root@localhost local]# tar -zxvf zookeeper-3.4.13.tar.gz
```

##### 三、编辑配置文件

1.进入conf目录：

```
[root@localhost local]# cd zookeeper-3.4.13/conf
```

\2. 将zoo_sample.cfg这个文件复制为zoo.cfg (必须是这个文件名)

```
[root@localhost conf]# cp  zoo_sample.cfg  zoo.cfg
```

\3. 进入zoo.cfg文件进行编辑

```
[root@localhost conf]# vim zoo.cfg
```

\4. 按 i 进入编辑模式，修改以下内容：

```
dataDir=/tmp/zookeeper/data
dataLogDir=/tmp/zookeeper/log
```

注意：如果想配置集群的话，请在clientPort下面添加服务器的ip。如

server.1=192.168.180.132:2888:3888
server.2=192.168.180.133:2888:3888

server.3=192.168.180.134:2888:3888
如果电脑内存比较小，zookeeper还可以设置成伪集群。也就是全部服务器采用同一个ip，但是使用不同的端口。

\5. 在tmp目录创建目录。

```
[root@localhost conf]# mkdir /tmp/zookeeper

[root@localhost conf]# mkdir /tmp/zookeeper/data
[root@localhost conf]# mkdir /tmp/zookeeper/log
```

 6.如果是配置集群，还需要在前面配置过的dataDir路径下新增myid文件

```
[root@localhost conf]# cd /tmp/zookeeper/data

[root@localhost data]# touch myid
[root@localhost data]# vim myid
```


在data目录下创建文件，文件名为“myid”, 编辑该“myid”文件，并在对应的IP的机器上输入对应的编号。
如在192.168.180.132上，“myid”文件内容就是1。在192.168.180.133上，内容就是2。



##### 四、配置环境变量

1.上面的操作都完事之后，我们需要配置一下环境变量，配置环境变量的命令如下：

```
[root@localhost zookeeper-3.4.13]# export ZOOKEEPER_INSTALL=/usr/local/zookeeper-3.4.13/
[root@localhost zookeeper-3.4.13]# export PATH=$PATH:$ZOOKEEPER_INSTALL/bin
```

 

##### 五、启动zookeeper

1.进入bin目录，并启动zookeep。如果不是在bin目录下执行，启动zookeeper时会报错： bash: ./zkServer.sh: No such file or directory

注意： ./zkServer.sh start前面的 . 不可忽略。

```
[root@localhost local]# cd /usr/local/zookeeper-3.4.13/bin
[root@localhost bin]# ./zkServer.sh start
```

2.启动成功效果如下：

```
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg
Starting zookeeper ... STARTED
```

3.zookeeper的服务端启动后，还需要启动zookeeper的客户端：

```
[root@localhost bin]# ./zkCli.sh
```

如果是连接多个不同的主机节点，可以使用如下命令：

```
./zkCli.sh -server 192.168.180.132:2888
```

启动成功效果如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
Connecting to localhost:2181..............................Welcome to ZooKeeper!
2018-10-25 21:04:54,407 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1029] - Opening socket connection to server localhost/0:0:0:0:0:0:0:1:2181. Will not attempt to authenticate using SASL (unknown error)
JLine support is enabled
2018-10-25 21:04:54,471 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@879] - Socket connection established to localhost/0:0:0:0:0:0:0:1:2181, initiating session
[zk: localhost:2181(CONNECTING) 0] 2018-10-25 21:04:54,501 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1303] - Session establishment complete on server localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x10000712e6f0000, negotiated timeout = 30000

WATCHER::

WatchedEvent state:SyncConnected type:None path:null
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

4.查看状态：



```
[root@localhost bin]# ./zkServer.sh status
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg
Mode: standalone
```

##### 遇到问题怎么解决？

zookeeper的出错日志会记录在 zookeeper.out。

当前处于哪个目录，执行完zkServer.sh start命令， zookeeper.out就会写在哪个目录。

vim zookeeper.out 可以查看报错信息。然后再搜索解决。

##### 六、zookeeper使用

通过 ./zkCli.sh 进入客户端后，就可以使用命令来操作zookeeper了。

1.创建节点

使用create命令，可以创建一个zookeeper节点。

create [-s]  [-e] path data acl

其中-s表示顺序节点，-e表示临时节点。默认情况下，创建的是持久节点。

path是节点路径，data是节点数据，acl是用来进行权限控制的。

如下：

创建一个叫做/zk-test的节点，内容是"123"

```
[zk: localhost:2181(CONNECTED) 0] create /zk-test 123
Created /zk-test
```

创建/zk-test的子节点book，内容是"233"

```
[zk: localhost:2181(CONNECTED) 7] create  /zk-test/book  233
Created /zk-test/book
```

 

2.查看节点内容

使用get命令，可以获取zookeeper指定节点的内容和属性信息。

如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[zk: localhost:2181(CONNECTED) 1] get /zk-test
123
cZxid = 0x3a
ctime = Sun Nov 11 21:50:44 CST 2018
mZxid = 0x3a
mtime = Sun Nov 11 21:50:44 CST 2018
pZxid = 0x3a
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

3.查看子节点

使用ls命令可以查看指定节点下的所有子节点

以下查看根目录下的所有子节点：

```
[zk: localhost:2181(CONNECTED) 2] ls /
[zk-test, zookeeper]
```

查看zk-test节点的子节点：

```
[zk: localhost:2181(CONNECTED) 3] ls /zk-test
[book]
```

 

4.更新节点内容

使用set命令，更新节点内容。格式为：

set  path data 

其中的data就是要更新的新内容。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[zk: localhost:2181(CONNECTED) 4] set /zk-test 456

cZxid = 0x3a
ctime = Sun Nov 11 21:50:44 CST 2018
mZxid = 0x3b
mtime = Sun Nov 11 22:05:20 CST 2018
pZxid = 0x3a
cversion = 0
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

在输出的信息中，可以发现，dataVersion的值由原来的0 变成了 1，这是因为刚才的更新操作导致该节点的数据版本也发生变更。

6.删除节点

使用delete命令来删除节点，如下：

```
[zk: localhost:2181(CONNECTED) 11] delete /zk-test
Node not empty: /zk-test
```

可以发现，一个节点存在子节点时，无法删除该节点。

删除子节点/zk-test/book，如下：

```
[zk: localhost:2181(CONNECTED) 12] delete /zk-test/book

WATCHER::

WatchedEvent state:SyncConnected type:NodeDeleted path:/zk-test/book
```

zookeeper中的watcher会监控节点，当子节点发生变化时会发出通知。此时提示子节点 /zk-test/book删除成功。

继续尝试删除节点 /zk-test，

```
[zk: localhost:2181(CONNECTED) 13] ls /zk-test
[]
[zk: localhost:2181(CONNECTED) 14] delete /zk-test
[zk: localhost:2181(CONNECTED) 15] ls /
[]
```

删除成功。

##### windows 安装 zookeeper

先准备安装包，这里我推荐在Apache官网下载（地址：https://zookeeper.apache.org/releases.html）。

解压复制 将conf目录下的zoo_sample.cfg文件，复制一份，重命名为zoo.cfg



修改zoo.cfg配置文件，将dataDir=/tmp/zookeeper修改成zookeeper安装目录所在的data文件夹（需要在安装目录下面新建一个空的data文件夹和log文件夹），再添加一条添加数据日志的配置，如下图



~~~
dataDir=
dataLogDir=
~~~

参数说明：

tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。
initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒
syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒
dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。
clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。

双击zkCli.cmd

### 5.5 Redis

#### 5.5.1 概述

​    REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。

Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。

#### 5.5.2 数据结构

- String: 字符串
- Hash: 散列
- List: 列表
- Set: 集合
- Sorted Set: 有序集合

#### 5.5.3 SpringBoot集成Redis

##### 5.5.3.1 yml配置

```yaml
spring:
#Redis
  redis:
    host: 127.0.0.1
    port: 6379
    password:
    #最大连接数
    pool:
        #连接池最大连接数（使用负值表示没有限制）
        max-active: 8
        #连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: -1
        #连接池中的最大空闲连接
        max-idle: 8
        #连接池中的最小空闲连接
        min-idle: 0
    #连接超时时间（毫秒）
    timeout: 30000
```

##### 5.5.3.2  RedisConfig

```java
@Configuration
@EnableCaching
@RefreshScope
public class RedisConfig extends CachingConfigurerSupport {

    @Value("${spring.redis.host}")
    private String host;
    @Value("${spring.redis.port}")
    private int port;
    @Value("${spring.redis.timeout}")
    private int timeout;
    @Value("${spring.redis.password}")
    private String password;
    @Value("${spring.redis.pool.max-active}")
    private int maxActive;
    @Value("${spring.redis.pool.max-wait}")
    private int maxWait;
    @Value("${spring.redis.pool.max-idle}")
    private int maxIdle;
    @Value("${spring.redis.pool.min-idle}")
    private int minIdle;

    @RefreshScope
    @Bean
    public KeyGenerator wiselyKeyGenerator(){
        return new KeyGenerator() {
            @Override
            public Object generate(Object target, Method method, Object... params) {
                StringBuilder sb = new StringBuilder();
                sb.append(target.getClass().getName());
                sb.append(method.getName());
                for (Object obj : params) {
                    sb.append(obj.toString());
                }
                return sb.toString();
            }
        };
    }

    @RefreshScope
    @Bean
    public JedisConnectionFactory redisConnectionFactory() {
        JedisConnectionFactory factory = new JedisConnectionFactory();
        factory.setHostName(host);
        factory.setPort(port);
        factory.setTimeout(timeout); //设置连接超时时间
        factory.setPassword(password);
        factory.getPoolConfig().setMaxIdle(maxIdle);
        factory.getPoolConfig().setMinIdle(minIdle);
        factory.getPoolConfig().setMaxTotal(maxActive);
        factory.getPoolConfig().setMaxWaitMillis(maxWait);
        return factory;
    }

    @RefreshScope
    @Bean
    public CacheManager cacheManager(RedisTemplate redisTemplate) {
//        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);
//        // Number of seconds before expiration. Defaults to unlimited (0)
//        cacheManager.setDefaultExpiration(10); //设置key-value超时时间
        return null;
    }

    @RefreshScope
    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory factory) {
        StringRedisTemplate template = new StringRedisTemplate(factory);
        setSerializer(template); //设置序列化工具，这样ReportBean不需要实现Serializable接口
        template.afterPropertiesSet();
        return template;
    }

    @RefreshScope
    private void setSerializer(StringRedisTemplate template) {
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setValueSerializer(jackson2JsonRedisSerializer);
    }
```

##### 5.5.3.3 RedisUtils

```java
@Service
public class RedisUtils {

    @Autowired
    private RedisTemplate redisTemplate;
    /**
     * 写入缓存
     * @param key
     * @param value
     * @return
     */
    public boolean set(final String key, Object value) {
        boolean result = false;
        try {
            ValueOperations<Serializable, Object> operations = redisTemplate.opsForValue();
            operations.set(key, value);
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }
    /**
     * 写入缓存设置时效时间
     * @param key
     * @param value
     * @return
     */
    public boolean set(final String key, Object value, Long expireTime , TimeUnit timeUnit) {
        boolean result = false;
        try {
            ValueOperations<Serializable, Object> operations = redisTemplate.opsForValue();
            operations.set(key, value);
            redisTemplate.expire(key, expireTime, timeUnit);
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }
    /**
     * 批量删除对应的value
     * @param keys
     */
    public void remove(final String... keys) {
        for (String key : keys) {
            remove(key);
        }
    }
    /**
     * 批量删除key
     * @param pattern
     */
    public void removePattern(final String pattern) {
        Set<Serializable> keys = redisTemplate.keys(pattern);
        if (keys.size() > 0){
            redisTemplate.delete(keys);
        }
    }
    /**
     * 删除对应的value
     * @param key
     */
    public void remove(final String key) {
        if (exists(key)) {
            redisTemplate.delete(key);
        }
    }
    /**
     * 判断缓存中是否有对应的value
     * @param key
     * @return
     */
    public boolean exists(final String key) {
        return redisTemplate.hasKey(key);
    }
    /**
     * 读取缓存
     * @param key
     * @return
     */
    public Object get(final String key) {
        Object result = null;
        ValueOperations<Serializable, Object> operations = redisTemplate.opsForValue();
        result = operations.get(key);
        return result;
    }
    /**
     * 哈希 添加
     * @param key
     * @param hashKey
     * @param value
     */
    public void hmSet(String key, Object hashKey, Object value){
        HashOperations<String, Object, Object> hash = redisTemplate.opsForHash();
        hash.put(key,hashKey,value);
    }
    /**
     * 哈希获取数据
     * @param key
     * @param hashKey
     * @return
     */
    public Object hmGet(String key, Object hashKey){
        HashOperations<String, Object, Object>  hash = redisTemplate.opsForHash();
        return hash.get(key,hashKey);
    }
    /**
     * 列表添加
     * @param k
     * @param v
     */
    public void lPush(String k,Object v){
        ListOperations<String, Object> list = redisTemplate.opsForList();
        list.rightPush(k,v);
    }
    /**
     * 列表获取
     * @param k
     * @param l
     * @param l1
     * @return
     */
    public List<Object> lRange(String k, long l, long l1){
        ListOperations<String, Object> list = redisTemplate.opsForList();
        return list.range(k,l,l1);
    }
    /**
     * 集合添加
     * @param key
     * @param value
     */
    public void add(String key,Object value){
        SetOperations<String, Object> set = redisTemplate.opsForSet();
        set.add(key,value);
    }
    /**
     * 集合获取
     * @param key
     * @return
     */
    public Set<Object> setMembers(String key){
        SetOperations<String, Object> set = redisTemplate.opsForSet();
        return set.members(key);
    }
    /**
     * 有序集合添加
     * @param key
     * @param value
     * @param scoure
     */
    public void zAdd(String key,Object value,double scoure){
        ZSetOperations<String, Object> zset = redisTemplate.opsForZSet();
        zset.add(key,value,scoure);
    }
    /**
     * 有序集合获取
     * @param key
     * @param scoure
     * @param scoure1
     * @return
     */
    public Set<Object> rangeByScore(String key,double scoure,double scoure1){
        ZSetOperations<String, Object> zset = redisTemplate.opsForZSet();
        return zset.rangeByScore(key, scoure, scoure1);
    }
```

##### Linux部署Redis

~~~shell
#安装C语言环境(已经安装可跳过)
yum install gcc-c++
#下载压缩包
wget http://download.redis.io/releases/redis-4.0.1.tar.gz
#解压
tar -zxvf redis-4.0.1.tar.gz
#进入解压目录并编译Redis
cd redis-4.0.1
#进行编译
make
#安装Redis
make install PREFIX=/usr/local/redis


~~~

PREFIX后面的/usr/local/redis是安装路径，我们启动redis的文件都在这里，也可以自定义。出现如下提示则安装成功：

~~~shell
make[1]: Entering directory `/root/redis-3.0.6/src'
​
Hint: It's a good idea to run 'make test' ;)
​
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
make[1]: Leaving directory `/root/redis-3.0.6/src
​
~~~

###### 拷贝配置文件并运行

接下把我们的配置文件redis.conf手动拷贝到安装路径,，以便开启后台运行与远程访问。

```
#拷贝redis.conf文件
cp -r redis.conf /usr/local/redis/bin/
```

![img](https://img-blog.csdn.net/20181006143827767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTkyOTAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

~~~
#开启服务端
./redis-server redis.conf
~~~

~~~
cd /usr/redis/
#链接此redis
./redis-cli  或者  ./redis-cli -h 127.0.0.1 -p 6379
 
~~~

-h：指定主机IP-p：指定主机端口默认主机IP是127.0.0.1 默认端口 6379不填则使用默认值

##### 设置后台进行和远程连接

###### **接下里我们在配置文件redis.conf中进行相关的配置**

```
#打开配置文件
vim redis.conf
 
```

在vim编辑模式下，输入行数+gg可以快捷跳行。例如跳到第138行，输入：138gg

##### 设置后台启动

###### **将第138行的daemonize no修改为daemonize yes即可**

![img](https://img-blog.csdn.net/20181006165018960?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTkyOTAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 开启远程访问

###### **将第70行的bind注释，第90行将protected-mode改为no**



重启redis

~~~
#首先查询到redis的pid后，kill掉,然后重启
[root@localhost bin]# ps -ef|grep redis
root      20940      1  0 12:12 ?        00:00:18 ./redis-server *:6379 
[root@localhost bin]# kill 20940
[root@localhost bin]# ./redis-server redis.conf 
​
~~~

![img](https://img-blog.csdn.net/20181006170328200?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTkyOTAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```
#远程连接
./redis-cli -h 你服务器的ip -p 6379 -a 你的密码
```

![img](https://img-blog.csdn.net/20181006171840614?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTkyOTAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)	

### 5.6 MongoDb

#### 5.6.1 概述

~~~
    MongoDB是一个基于分布式文件存储 [1]  的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。
    MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。
~~~

#### 5.6.2 windows集成

#### 5.6.3 Linux集成

~~~shell
环境搭建：
   1 下载Linux包
    wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.2.12.tgz
   
   2  解压
   tar -zxvf mongodb-linux-x86_64-3.2.12.tgz /usr/local/mongo
   
   3  配置系统文件profile
   
     sudo vi /etc/profile
  
  插入下列内容：  

    export MONGODB_HOME=/usr/local/mongodb  
    export PATH=$PATH:$MONGODB_HOME/bin
    
    source /etc/profile
    
   4 创建用于存放数据和日志文件的文件夹，并修改其权限增加读写权限
   cd /usr/local/mongodb
   sudo mkdir -p data/db
   sudo chmod -R 777 data/db
   sudo mkdir logs
   cd logs
   sudo touch mongodb.log
   
   5 进入到bin目录，增加一个配置文件
   cd /usr/local/mongodb/bin  
   sudo vi mongodb.conf
~~~

##### MongoDB启动配置

~~~shell
dbpath = /usr/local/mongodb/data/db #数据文件存放目录  
logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录  
port = 28017  #默认端口27017  
fork = true  #以守护程序的方式启用，即在后台运行  
nohttpinterface = true 

~~~

##### 启动配置

~~~shell
启动mongod数据库服务，以配置文件的方式启动


cd /usr/local/mongodb/bin
./mongod -f mongodb.conf
 
[wj@bogon bin]$ sudo ./mongod -f mongodb.conf --logappend
about to fork child process, waiting until server is ready for connections.
forked process: 6385
all output going to: /usr/local/mongodb/logs/mongodb.log
child process started successfully, parent exiting
~~~

##### 连接数据库

~~~
./mongo

在浏览器中诊断访问http://XXXX:27017

You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number

~~~
